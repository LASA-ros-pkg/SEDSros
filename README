Seds Notes
J. Stober
Last updated: 7.11.2011

== Running Seds (PR2) ==

The main "walk-through" script is in pr2/master_pr2.sh. This script
prompts the user to record example trajectories, performs optimization
using SEDS, then drives the robot using pr2_driver.py and the learned
parameters. For running everything manually (without prompts) see below.

== Running Seds (WAM) ==

There is now a wam/master_wam.sh script for running SEDS using the WAM
robot. While both seds_node and ds_node are written to be generic
(preforming operations on SedsMessages and SedsModels) the wam2seds.py
and wam_driver.py scripts needed robot specific customization (compare
with tf2seds.py and pr2_driver.py).

tf2seds.py does not work with the current WAMros node since that node
does not publish to /tf. In other respects, this part of the toolchain
is fairly generic as well. The robot driver requires some
customization of the control topic and is otherwise the same.

=== Short Version (Manual) ===

1. Collect some sample bagfiles of tf data in a directory.

2. In the pr2 directory run:

   ./train.sh <location of directory containing bagfiles>

   (e.g. ./train.sh ../data/bags/pr2/20110615/ )

3. In the pr2 directory run: *WILL MOVE THE ROBOT*

   ./drive.sh

   (e.g. ./run.sh)

(Alt.) To run the ds_server and record the results in a bagfile instead of sending them to the robot:

   ./run_test.sh <location of bagfile to write>

   (e.g. ./run_test.sh ../data/bags/pr2/seds/seds_model.bag)

The bagfile can then be opened in rxbag to give a sense of how the trajectories would look from a few sample starting position.

=== Long Version ===

There are three major components to this demonstration
project:

1. Collecting sample trajectories.

   The easiest way to collect data on the PR2 seems to be to turn off
   all arm controllers, run "rosbag record /tf", then move the arm
   manually. Doing this several times from different starting
   positions (and recording separate /tf bagfiles) will create the set
   of trajectories that SEDS will use as samples for learning.

   The trajectories should be stored in a single directory and should
   be the only bagfiles in that directory.

1a. Translating rosbags into a usable form.

   - nodes/tf2seds.py

   Rosbags with tf messages need to be translated into a form that
   SEDS can understand. This translation process requires iterating
   through the set of tf messages, loading the tf transforms, then
   computing the desired transform. In the case of the PR2 robot, the
   (source,target) for computing the desired transform is
   (torso_lift_link, r_gripper_tool_frame). The result of this
   computation is a set of end effector Cartesian coordinates and
   orientations. This data is then written to a new bag in as a
   sequence of SedsMessage.

   A SedsMessage contains:

       # trajectory poses
       float64[] x

       # trajectory derivatives
       float64[] dx

       # time span for dx calculation
       duration dt

       # time of the current x value
       time t

       # trajectory number
       uint32	  index

   Note that multiple rosbags of tf information need to be written
   into a single SedsMessage bag. The python script nodes/tf2seds.py
   does this for bags collected from real or simulated PR2 robots. It
   is not set up as a ros node.

   Example usage:
   rosrun seds tf2seds.py -b <path_to_tf_bag_files> -o <path_to_seds_bagfile>

2. Running SEDS to learn model parameters.

   Running SEDS is as easy as "rosrun seds seds_node". This starts the
   seds_node which makes available a single service "seds/optimize"
   which takes arguments of the following form:

   rosservice call seds/optimize"seds.bag"

   The first argument is the location of a SedsMessage bag. The second
   argument tells /seds/optimize the kind of input (SedsMessage). The
   third argument tells the service where to write out the SEDS
   parameters.

3. Driving the robot using ADS.

   - ds_node

   To actually drive the robot requires running two nodes. The first
   is ds_node:

   rosrun seds ds_node

   The ds_node provides two services. The first is load_model which
   loads parameters from a running seds_node.

   rosservice call /ds_node/load_model

   You can also load from a file (generated using seds_node seds/savefile).

   rosservice call /ds_node/load_file <file>

   The next service is /ds_node/ds_server and is meant to be called from within
   the main loop of a controlling node. This service takes as
   arguments an array of floats x (representing the current Cartesian
   coordinates) and returns another array of floats dx. See the DSSrv
   srv file for further details.

   For debugging purposes, this service can be called on the command
   line with an array of sample coordinates:

   rosservice call /ds_node/ds_server "[0.1, 0.1, 0.1]"

   - pr2_driver.py

   pr2_driver.py is the script that actually drives the robot. The
   mainloop does three things: 1. Reads the current coordinates using a
   TF Listener. 2. Sends these to /ds_node/ds_server and reads the
   response. 3. Composes new coordinates x+dx and publishes these to the
   r_cart/command_pose topic.

   If the model is correct, this loop should drive the robot in much
   the same way as the example trajectories.

   The script pr2/init.sh sets up both ds_node and pr2_driver.py
   but you can start pr2_driver.py manually:

   rosrun seds pr2_driver.py

   Make sure you have a ds_node running with the proper parameters
   already loaded.

== Current Issues ==

Velocity Problem:

So, with run_test, it looks like the system does exactly the right
thing, which is great.  Unfortunately, this doesn't seem to carry over
to the real robot (and to a lesser extent, in simulation).  I think I
know what the problem is.  At some position x, the computed delta dx
isn't different enough to cause the cartesian controller to actually
move the arm.  So the arm stays where it is, and nothing changes.  I've
some theories:

1) Friction not being modeled in the controller
2) Bad controller (maybe we should try the Jinv controller?)
3) our velocities are too small (making issues 1 and 2 more apparent)

I focused on 3, because I remember Mohammad telling me something about
how setting dT correctly is very important, even though mathematically
it shouldn't matter.  So for today, I threw in a multiplier on the
velocity, and that seemed to make the problem go away.

== Other Tools ==

Some other code that might be useful:
1. pr2/run_tf_bag.py -- This script reads /tf_old topic and published to r_cart/command_pose. The idea is that you can replay bags using this by running

rosbag play bag_with_tf.bag tf:=tf_old

To get this to work in simulation usually requires running the back at a slower frequency than it was recorded.

2. pr2/publish_rcart.py -- Takes Cartesian coordinates on the command line and publishes them continually to r_cart/command_position. Useful for moving the simulated robot to a set pose.

3. nodes/run_test.sh -- Continually calls /ds_node/ds_server from various starting points and records the resulting trajectories in a bag file that you can analyze using rxbag. This is like running the system but without the robot.

   Ex. ./run_test.sh ../data/bags/pr2/seds/seds_model.bag

== TODO ==

* Smooth dx values.
* Incorporate new SEDS optimization method.
* Friction trap prevention.

== References ==

=== PR2 Remote Lab URLs ===
* http://mjpeg.pr2-remotelab.com:8080/stream?topic=/remote_lab_cam1/image_raw
* http://pr2-remotelab.com/demo/wviz.html
* http://pr2-remotelab.com/demo/wviz_vizonly.html

=== Parameter File Format ===

Based on SEDS.cpp:

First Line: 		d
Second Line: 		K
Third Line: 		Priors
Next 2*d Lines:	Mu
Next 2*d Lines:	Sigma(:,:,1)
...
Next 2*d Lines:	Sigma(:,:,K)

Note: Everything in the GMM is scaled by a factor of 1000x. This scale
factor holdover from mldemos code.

